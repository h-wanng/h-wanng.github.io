[{"content":"在easyExcel中使用LongestMatchColumnWidthStyleStrategy做列宽适配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private Integer dataLength(List\u0026lt;WriteCellData\u0026lt;?\u0026gt;\u0026gt; cellDataList, Cell cell, Boolean isHead) { if (isHead) { return cell.getStringCellValue().getBytes().length; } else { WriteCellData\u0026lt;?\u0026gt; cellData = (WriteCellData)cellDataList.get(0); CellDataTypeEnum type = cellData.getType(); if (type == null) { return -1; } else { switch (type) { case STRING: return cellData.getStringValue().getBytes().length; case BOOLEAN: return cellData.getBooleanValue().toString().getBytes().length; case NUMBER: return cellData.getNumberValue().toString().getBytes().length; default: return -1; } } } } 由于此策略中获取宽度逻辑为直接直接byte长度，导致如果三字节的字符（中文）过多就会变得很宽，一字节（英文）的字符过多就会不够宽\n重新编写自定义列宽策略实现根据字符的字节长度设置列宽:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class CustomColumnWidthStyleStrategy extends AbstractColumnWidthStyleStrategy { private static final int MAX_COLUMN_WIDTH = 255; private final Map\u0026lt;Integer, Map\u0026lt;Integer, Integer\u0026gt;\u0026gt; cache = MapUtils.newHashMapWithExpectedSize(8); public CustomColumnWidthStyleStrategy() {} protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List\u0026lt;WriteCellData\u0026lt;?\u0026gt;\u0026gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) { boolean needSetWidth = isHead || !CollectionUtils.isEmpty(cellDataList); if (needSetWidth) { Map\u0026lt;Integer, Integer\u0026gt; maxColumnWidthMap = this.cache.computeIfAbsent(writeSheetHolder.getSheetNo(), (key) -\u0026gt; new HashMap\u0026lt;\u0026gt;(16)); double columnWidth = this.dataLength(cellDataList, cell, isHead); if (columnWidth \u0026gt;= 0) { if (columnWidth \u0026gt; MAX_COLUMN_WIDTH) { columnWidth = MAX_COLUMN_WIDTH; } Integer maxColumnWidth = maxColumnWidthMap.get(cell.getColumnIndex()); if (maxColumnWidth == null || columnWidth \u0026gt; maxColumnWidth) { maxColumnWidthMap.put(cell.getColumnIndex(), (int) columnWidth); writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), (int) columnWidth * 256); } } } } private double dataLength(List\u0026lt;WriteCellData\u0026lt;?\u0026gt;\u0026gt; cellDataList, Cell cell, Boolean isHead) { if (isHead) { return getExcelWidth(cell.getStringCellValue()); } else { WriteCellData\u0026lt;?\u0026gt; cellData = cellDataList.get(0); CellDataTypeEnum type = cellData.getType(); if (type == null) { return 0; } else { switch (type) { case STRING: return this.getExcelWidth(cellData.getStringValue()); case BOOLEAN: return this.getExcelWidth(cellData.getBooleanValue().toString()); case NUMBER: return this.getExcelWidth(cellData.getNumberValue().toString()); default: return 0; } } } } /** * 调整单元格字符字节宽度 */ private double getExcelWidth(String str) { double length = 0; char[] chars = str.toCharArray(); for (char c : chars) { byte[] bytes = this.getUtf8Bytes(c); if (bytes.length == 1) { length += 1.6; } if (bytes.length == 2) { length += 2.2; } if (bytes.length == 3) { length += 3.85; } if (bytes.length == 4) { length += 4.2; } } return length; } private byte[] getUtf8Bytes(char c) { char[] chars = {c}; CharBuffer charBuffer = CharBuffer.allocate(chars.length); charBuffer.put(chars); charBuffer.flip(); ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(charBuffer); return byteBuffer.array(); } } ","date":"2024-09-19T00:00:00Z","permalink":"https://h-wanng.github.io/p/easyexcel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E5%AE%BD%E6%A0%B7%E5%BC%8F%E7%AD%96%E7%95%A5/","title":"Easyexcel自定义列宽样式策略"},{"content":"1. 导入依赖模块 1 2 3 4 5 import express from \u0026#39;express\u0026#39;; import { createServer } from \u0026#39;http\u0026#39;; import { WebSocket, WebSocketServer } from \u0026#39;ws\u0026#39;; import { fileURLToPath } from \u0026#39;url\u0026#39;; import { join, dirname } from \u0026#39;path\u0026#39;; express：用于创建 HTTP 服务器和处理 HTTP 请求，特别是提供静态文件。 createServer：从 http 模块导入，用于创建一个基本的 HTTP 服务器，它可以与 WebSocket 服务器一起运行。 WebSocket 和 WebSocketServer：用于创建 WebSocket 服务器，处理双向实时通信。 fileURLToPath 和 dirname：这些是处理 ES 模块中的 __dirname 的方法，通常 __dirname 只在 CommonJS 模块系统中可用，这里使用这两个方法来模拟获取当前文件路径。 2. 获取 __dirname 1 2 const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename); 在 ES 模块（import 语法）中，无法直接使用 __dirname。所以通过 fileURLToPath 将 import.meta.url 转换为文件路径，然后用 dirname 获取当前文件所在的目录路径。 3. 创建 Express 应用和 HTTP 服务器 1 2 const app = express(); const server = createServer(app); app 是使用 express() 创建的一个 Express 应用，它用于处理 HTTP 请求和路由。 server 是通过 createServer 创建的 HTTP 服务器，它使用 app 作为处理请求的回调。这个服务器不仅可以处理 HTTP 请求，还可以与 WebSocket 服务器集成。 4. 设置 WebSocket 服务器 1 const wss = new WebSocketServer({ server }); wss 是一个 WebSocket 服务器，创建时将 HTTP 服务器作为参数传入。这样，HTTP 服务器既可以处理普通的 HTTP 请求，也可以处理 WebSocket 连接。 5. 处理 WebSocket 连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 wss.on(\u0026#39;connection\u0026#39;, (ws) =\u0026gt; { // 设定心跳检测时间间隔 const interval = setInterval(() =\u0026gt; { if (ws.readyState === WebSocket.OPEN) { ws.ping(); // 发送 ping 消息，检测客户端是否存活 } }, 30000); // 每30秒发送一次心跳检测 ws.on(\u0026#39;pong\u0026#39;, () =\u0026gt; { console.log(\u0026#39;received pong from client\u0026#39;); }); ws.on(\u0026#39;message\u0026#39;, (message) =\u0026gt; { console.log(\u0026#39;ws message\u0026#39;) const data = JSON.parse(message); }); ws.on(\u0026#39;close\u0026#39;, () =\u0026gt; { clearInterval(interval); // 当连接关闭时清理定时器 console.log(\u0026#39;ws close\u0026#39;); }); }); wss.on(\u0026lsquo;connection\u0026rsquo;, \u0026hellip;)：当一个客户端通过 WebSocket 连接到服务器时触发，ws 是与该客户端的 WebSocket 连接对象。 ws.ping()：定期向客户端发送 ping 消息，客户端会自动响应 pong 消息，这可以确保连接的活跃状态。 ws.on(\u0026lsquo;pong\u0026rsquo;, \u0026hellip;)：处理客户端返回的 pong 消息，证明连接仍然活跃。WebSocket 协议规定，当客户端接收到 ping 帧时，会自动回复一个 pong 帧。 ws.on(\u0026lsquo;message\u0026rsquo;, \u0026hellip;)：当服务器收到来自客户端的消息时触发。这里的消息被假设为 JSON 格式，所以用 JSON.parse 进行解析。 ws.on(\u0026lsquo;close\u0026rsquo;, \u0026hellip;)：当客户端关闭 WebSocket 连接时触发，记录连接关闭的日志。 6. 提供静态文件 1 app.use(express.static(join(__dirname, \u0026#39;../public/dist\u0026#39;))); app.use：设置 Express 静态文件中间件，用于提供静态文件，如 HTML、CSS、JS 文件。 join(__dirname, \u0026lsquo;../public/dist\u0026rsquo;)：将当前文件的目录与 ../public/dist 拼接，表示静态文件位于服务器的 public/dist 目录中。 7. 启动服务器 1 2 3 4 const PORT = 3000; server.listen(PORT, () =\u0026gt; { console.log(`Server is listening on http://localhost:${PORT}`); }); server.listen(PORT, \u0026hellip;)：启动 HTTP 服务器并监听 3000 端口。当服务器启动后，会输出 Server is listening on http://localhost:3000。 8. 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import express from \u0026#39;express\u0026#39;; import { createServer } from \u0026#39;http\u0026#39;; import { WebSocket, WebSocketServer } from \u0026#39;ws\u0026#39;; import { fileURLToPath } from \u0026#39;url\u0026#39;; import { join, dirname } from \u0026#39;path\u0026#39;; // 获取 __dirname const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename); // 创建 Express 应用和 HTTP 服务器 const app = express(); const server = createServer(app); // 设置 WebSocket 服务器 const wss = new WebSocketServer({ server }); wss.on(\u0026#39;connection\u0026#39;, (ws) =\u0026gt; { // 设定心跳检测时间间隔 const interval = setInterval(() =\u0026gt; { if (ws.readyState === WebSocket.OPEN) { ws.ping(); // 发送 ping 消息，检测客户端是否存活 } }, 30000); // 每30秒发送一次心跳检测 ws.on(\u0026#39;pong\u0026#39;, () =\u0026gt; { console.log(\u0026#39;received pong from client\u0026#39;); }); ws.on(\u0026#39;message\u0026#39;, (message) =\u0026gt; { console.log(\u0026#39;ws message\u0026#39;) const data = JSON.parse(message); }); ws.on(\u0026#39;close\u0026#39;, () =\u0026gt; { clearInterval(interval); // 当连接关闭时清理定时器 console.log(\u0026#39;ws close\u0026#39;); }); }); // 配置 Express 处理静态文件 app.use(express.static(join(__dirname, \u0026#39;../public/dist\u0026#39;))); // 启动服务器 const PORT = 3000; server.listen(PORT, () =\u0026gt; { console.log(`Server is listening on http://localhost:${PORT}`); }); ","date":"2024-09-19T00:00:00Z","permalink":"https://h-wanng.github.io/p/node.js-websocket%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"Node.js websocket服务器"},{"content":"Spring中常出现对于Service的多实现来处理不同业务。例如有一个告警上报的业务场景，需要处理不同类型的告警。又如通过继承抽象类的方式处理不同类型日志类型内容的生成。\n可以使用ApplicationContext或三方工具SpringUtil.getBean(Xxx.class);获取Bean。也可使用Spring的依赖注入和策略模式来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Component public class MyServiceFactory { private final Map\u0026lt;String, MyService\u0026gt; serviceMap; @Autowired public MyServiceFactory(List\u0026lt;MyService\u0026gt; services) { serviceMap = services.stream().collect(Collectors.toMap( service -\u0026gt; service.getClass().getSimpleName().replace(\u0026#34;MyServiceImpl\u0026#34;, \u0026#34;\u0026#34;).toLowerCase(), service -\u0026gt; service )); } public MyService getService(String type) { MyService service = serviceMap.get(type.toLowerCase()); if (service == null) { throw new IllegalArgumentException(\u0026#34;Unknown service type: \u0026#34; + type); } return service; } } 使用工厂类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class MyController { private final MyServiceFactory myServiceFactory; @Autowired public MyController(MyServiceFactory myServiceFactory) { this.myServiceFactory = myServiceFactory; } @GetMapping(\u0026#34;/process\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; process(@RequestParam String type) { MyService myService = myServiceFactory.getService(type); myService.process(); return ResponseEntity.ok(\u0026#34;Processing done by \u0026#34; + type); } } ","date":"2024-09-18T00:00:00Z","permalink":"https://h-wanng.github.io/p/service-factory/","title":"Service Factory"},{"content":"对于特殊的上传需求：上传成功后展示成功相关信息的提示语，而失败通过Excel文件下载展示详细的错误数据及错误原因。通常可以在出错后生成Excel文件，并保存至服务器或上传到minio，再返回文件地址，这样返回结果类型统一。\n也可在错误时直接通过response返回二进制数据流，需要在前端请求后判断响应的数据类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 axios.post( this.upload.url, params, { responseType: \u0026#39;blob\u0026#39;, headers: this.upload.headers } ).then(response =\u0026gt; { if (response.data.type === \u0026#39;application/json\u0026#39;) { return response.data.text() } else { this.$confirm(\u0026#39;批量导入信息失败，请下载失败文件查看详情！\u0026#39;, \u0026#39;提示\u0026#39;, { confirmButtonText: \u0026#39;确定\u0026#39;, cancelButtonText: \u0026#39;取消\u0026#39;, type: \u0026#39;warning\u0026#39; }).then(() =\u0026gt; { const blob = new Blob([response.data]) const a = document.createElement(\u0026#39;a\u0026#39;) const url = URL.createObjectURL(blob) const filename = \u0026#39;批量导入失败原因文件\u0026#39; + \u0026#39;.xlsx\u0026#39; a.href = url a.download = filename a.click() URL.revokeObjectURL(url) this.upload.open = false this.upload.isUploading = false this.$refs.upload.clearFiles() }) } }).then(text =\u0026gt; { if (!text) return const response = JSON.parse(text) this.upload.open = false this.upload.isUploading = false this.$refs.upload.clearFiles() let title = \u0026#39;\u0026#39; if (response.code === 200) { title = response.msg } else { title = response.message } this.$alert( \u0026#39;\u0026lt;div style=\\\u0026#39;overflow: auto;overflow-x: hidden;max-height: 70vh;padding: 10px 20px 0;\\\u0026#39;\u0026gt;\u0026#39; + title + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;, \u0026#39;导入结果\u0026#39;, { dangerouslyUseHTMLString: true } ) this.getDeptTree() }).finally(() =\u0026gt; { this.loading = false }) ","date":"2024-06-06T00:00:00Z","permalink":"https://h-wanng.github.io/p/axios%E8%AF%B7%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E6%88%96json%E5%A4%84%E7%90%86/","title":"axios请求二进制流或json处理"},{"content":"CSS超长内容自动滚动 场景为在限定的空间（宽度）内展示超出容器宽度范围的内容。此时若按不换行的方式展示，内容必定被遮挡，用户无法获取完整信息内容。当然可以尝试让超出显示为省略号，鼠标移入时展示完整内容。但此类方法有限制，如用户友好性低、复杂场景难实现等问题。\n这里总结使用CSS(animation)实现超长内容自动滚动(轮播)效果。\n首先需要一个固定宽度的容器包围超长内容，使超长内容能够在限定空间内滚动，这里使用class为scroll-wrap的div作为父容器，class为scroll-item的div作为超长内容div\n1 2 3 4 5 6 .scroll-wrap { max-width: 100%; margin: 10px 0; overflow: hidden; white-space: nowrap; } 为父容器设定固定的最大宽度max-width，使用overflow: hidden;将超出的内容隐藏，另外在父容器或子容器中设置\nwhite-space: nowrap;使文本超出容器宽度不换行。\n而滚动效果动画加在子容器上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .scroll-item { color: #cc3d00; font-size: 14px; line-height: 1; float: left; animation: scroll linear 4s alternate infinite; } @keyframes scroll { 0% { margin-left: 0; transform: translateX(0); } 100% { margin-left: 100%; transform: translateX(-100%); } } float: left;让div居左显示，定义keyframes关键帧结合动画让div实现滚动效果。最终实现效果为开头文字居左显示，结束文字居右显示。margin-left: 0; transform: translateX(0);让div居左，在最终状态下，margin-left: 100%;让整个超长div最左边对齐到父div的最右边，transform: translateX(-100%);使超长div向左平移自身宽度100%，从而让超长div最右边对齐到父div的最右边。\n最后再给动画加两个关键帧，使超长内容滚动在起始和结束位置停留\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @keyframes scroll { 0% { margin-left: 0; transform: translateX(0); } 10% { margin-left: 0; transform: translateX(0); } 90% { margin-left: 100%; transform: translateX(-100%); } 100% { margin-left: 100%; transform: translateX(-100%); } } ","date":"2024-05-21T00:00:00Z","permalink":"https://h-wanng.github.io/p/css%E8%B6%85%E9%95%BF%E5%86%85%E5%AE%B9%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8/","title":"CSS超长内容自动滚动"},{"content":"Java目录及子目录文件读取 在 Java 中，File 类提供了多个方法来获取目录下的文件，包括 list()、listFiles() 和 walk() 方法。这些方法分别有不同的用途和特点。\nlist() list() 方法返回一个字符串数组，包含该目录下所有文件和目录的名称（不包括子目录中的内容）。例如，下面的代码获取当前目录下所有文件和目录的名称： 1 2 3 4 5 File directory = new File(\u0026#34;.\u0026#34;); String[] fileList = directory.list(); for (String fileName : fileList) { System.out.println(fileName); } listFiles() listFiles() 方法返回一个 File 对象数组，包含该目录下所有文件和目录的文件对象（不包括子目录中的内容）。例如，下面的代码获取当前目录下所有文件和目录的文件对象： 1 2 3 4 5 File directory = new File(\u0026#34;.\u0026#34;); File[] fileList = directory.listFiles(); for (File file : fileList) { System.out.println(file.getName()); } walk() walk() 方法可以递归地遍历一个目录下的所有文件和子目录，并返回一个流（Stream），该流包含所有文件和目录的 File 对象。例如，下面的代码获取当前目录及其所有子目录下的所有文件和目录的文件对象： 1 2 3 4 5 6 Path start = Paths.get(\u0026#34;.\u0026#34;); try (Stream\u0026lt;Path\u0026gt; stream = Files.walk(start)) { stream.filter(Files::isRegularFile) .filter(path -\u0026gt; path.toString().endsWith(\u0026#34;.sql\u0026#34;)) .forEach(System.out::println); } 方法的选择需要根据实际需求来决定。例如，如果只需要获取文件和目录的名称，可以使用 list() 方法；如果需要获取文件和目录的 File 对象，则可以使用 listFiles() 方法；如果需要递归地遍历目录下的所有文件和子目录，则可以使用 walk() 方法。\n如下是各个方法的优缺点：\nlist()\n优点：\nlist() 方法获取目录下所有文件和目录的名称，返回结果简单，使用方便。 对于大型目录，list() 方法通常比 listFiles() 方法更快，因为它只返回文件名而不是文件对象，所以不需要加载整个文件对象到内存中。 缺点：\nlist() 方法无法获取文件对象，只能获取文件名称，如果需要使用文件对象，就需要进一步转换。 list() 方法无法递归遍历目录下的子目录，只能获取当前目录下的所有文件和目录的名称。 listFiles()\n优点：\nlistFiles() 方法获取目录下所有文件和目录的文件对象，方便进行进一步的操作。 可以通过 isDirectory() 和 isFile() 方法判断文件是否是目录或文件。 可以通过传入 FilenameFilter 或 FileFilter 对象进行过滤，只获取满足条件的文件对象。 缺点：\n对于大型目录，listFiles() 方法可能会耗费大量内存，因为它返回的是文件对象而不是文件名。 listFiles() 方法无法递归遍历目录下的子目录，只能获取当前目录下的所有文件和目录的文件对象。 walk()\n优点：\nwalk() 方法可以递归地遍历目录下的所有文件和子目录，非常方便。 返回的是一个 Stream 对象，可以轻松地对文件进行过滤、排序、分组等操作。 缺点：\nwalk() 方法可能会遍历到非常深的目录层级，如果目录结构比较复杂，可能会导致遍历时间很长。 返回的是 File 对象流，可能会占用大量内存。 walk() 方法只在 Java 8 及以上版本中可用，如果需要在较早版本中使用，需要使用其他方法或者自己编写递归方法。 对于目录层级适当，且需要递归读取的情况walk()较为合适。可使用 Files.walk() 方法来递归地遍历目录下的所有文件和子目录，并以文件输入流的方式读取文件内容。但需要注意的是，在处理文件内容时，需要根据实际情况进行相应的处理。例如，如果文件内容是文本文件，可以使用 BufferedReader 来读取文件内容，如果是二进制文件，可以使用 InputStream 来读取文件内容，并根据实际情况进行解析和处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.io.*; import java.nio.file.*; import java.util.stream.*; public class ReadFiles { public static void main(String[] args) throws IOException { String dirPath = \u0026#34;path/to/directory\u0026#34;; try (Stream\u0026lt;Path\u0026gt; stream = Files.walk(Paths.get(dirPath))) { stream.filter(Files::isRegularFile) .forEach(path -\u0026gt; { try (InputStream in = Files.newInputStream(path)) { // 处理文件内容 // 例如解析文件，或将文件内容存入数据库等操作 } catch (IOException e) { e.printStackTrace(); } }); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.io.*; import java.nio.file.*; import java.util.stream.*; public class ReadFiles { public static void main(String[] args) throws IOException { String dirPath = \u0026#34;path/to/directory\u0026#34;; try (Stream\u0026lt;Path\u0026gt; stream = Files.walk(Paths.get(dirPath))) { stream.filter(Files::isRegularFile) .forEach(path -\u0026gt; { try (BufferedReader br = Files.newBufferedReader(filePath, StandardCharsets.UTF_8)) { // 处理文件内容 } catch (IOException e) { e.printStackTrace(); } }); } } } ","date":"2023-05-05T00:00:00Z","permalink":"https://h-wanng.github.io/p/java%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%AD%90%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/","title":"Java目录及子目录文件读取"},{"content":"MySQL 特定值在结果中的位置（序号） 1 2 3 4 5 select tt.rn from ( select t.id, (@rn := @rn + 1) as rn from ( select * from t_example te where te.a = \u0026#39;a\u0026#39; and te.b = \u0026#39;b\u0026#39; order by te.id ) t cross join (select @rn := 0) params ) tt where tt.id = \u0026#39;123\u0026#39; 1 2 3 select t.rn from ( select te.id, (@rn := @rn + 1) as rn from t_example te cross join (select @rn := 0) params where te.a = \u0026#39;a\u0026#39; and te.b = \u0026#39;b\u0026#39; order by te.id ) t where t.id = \u0026#39;123\u0026#39; 可先在内层select子句中将满足指定条件的数据查询出来，并按特定字段进行排序。然后为查询结果增加行号，最后即可查询出特定值在结果中的位置。\n也可直接为查询结果加上行号，再查询特定值的序号。\n其中，@xx 为用户变量，@符号后加上变量名，用于定义一个变量。为变量赋值使用的符号为:=，如：\n1 select @i := 1, @i := @i + 1, @i := @i + 1 1 2 3 @i := 1|@i := @i + 1|@i := @i + 1| -------+------------+------------+ 1| 2.0| 3.0| 而(select @rn := 0) params 结果只有一行，与其进行笛卡尔乘积等于在结果集中增加一行，以此实现查询行号。\n1 select * from (select 1, 2, 3) t1 cross join (select 4) t2 1 2 3 1|2|3|4| -+-+-+-+ 1|2|3|4| 但在使用中发现MySQL提示这种用户变量定义方式已经弃用：\nSetting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.\n查询发现还有另一种实现行号的方法，即通过row_number() over(order by )，因此上文中的查询语句可改为：\n1 select t.rn from (select id, row_number() over(order by id) as rn from t_example where a = \u0026#39;a\u0026#39; and b = \u0026#39;b\u0026#39;) t where t.id = \u0026#39;123\u0026#39; ","date":"2023-03-03T00:00:00Z","permalink":"https://h-wanng.github.io/p/mysql-%E7%89%B9%E5%AE%9A%E5%80%BC%E5%9C%A8%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE/","title":"MySQL 特定值在结果中的位置"},{"content":"Ruoyi 字典取值并回显到页面 1 2 3 4 5 \u0026lt;el-table-column label=\u0026#34;职级\u0026#34; align=\u0026#34;center\u0026#34; key=\u0026#34;job_grade\u0026#34; prop=\u0026#34;job_grade\u0026#34; :show-overflow-tooltip=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;dict-tag :options=\u0026#34;dict.type.job_grade_type\u0026#34; :value=\u0026#34;scope.row.job_grade\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; 通过 slot-scope scope.row.job_grade 获取当前column的prop，在字典中获取对应数据（label）\nRuoyi vue下拉框取字典表值回显为数字不是文字 业务场景为点击el-table-column中的修改操作弹出dialog并自动填充当前行的实体信息。Dialog中表单其中一项为下拉框，数据绑定（v-model）的值为value，需要根据value从字典中取对应的label并回显。\n具体实现中出现回显的是数字而非label文本。\n原因为Ruoyi中字典数据表的键和值均为 varchar 类型，而自己的数据表相关字段为 int\n1 2 `dict_label` varchar(100) DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;字典标签\u0026#39;, `dict_value` varchar(100) DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;字典键值\u0026#39;, 解决方法：\n将数据表（实体）中的字段改为varchar。\n将value的值用Number包起来：\n1 2 3 4 5 6 7 8 \u0026lt;el-select v-model=\u0026#34;form.job_grade\u0026#34; clearable placeholder=\u0026#34;请选择职级\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;dict in dict.type.job_grade_type\u0026#34; :key=\u0026#34;dict.value\u0026#34; :label=\u0026#34;dict.label\u0026#34; :value=\u0026#34;Number(dict.value)\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; JS中null和undefined 遇见一个有意思的小问题。 业务场景为Dialog中表单的数据提交，id没有值，后端通过雪花算法生成自增id，前端中JS异步传值（整个表单的值）。 当表单参数中有初始化，且id默认设为null时，如：\n1 2 3 4 form: { id: null, ... } 后端接收到的数据为\u0026quot;id\u0026quot;: nil。将id设置为\u0026rsquo;\u0026rsquo;,也是一样的情况，最终导致，插入（insert）数据报错，错误信息大致为 字段被定义两次。\n解决办法就是不初始化参数，或将其初始化为undefined。\nundefined和null的区别: 6、undefined和null的用途 null表示没有对象，即不应该有值，经常用作函数的参数，或作为原型链的重点。\nundefined表示缺少值，即应该有值，但是还没有赋予（变量提升时默认会赋值为undefined，函数参数未提供默认为undefined，函数的返回值默认为undefined） 但不建议显式赋值为undefined：\n1 建议：无论在什么情况下都没有必要将一个变量显示的赋值为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null. Vue中标签中拼接变量 通过v-bind，如：\n1 2 \u0026lt;router-link v-bind:to=\u0026#34;`/biz/tr/trainer_detail/index/${this.trainerId}`\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;`/biz/tr/trainer_detail/index/${this.trainerId}`\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; 页面返回后刷新数据 使用钩子函数\n1 2 3 4 activated() { //获取数据方法 this.getList(); }, 父子组件的值传递 TODO\nprops\nVue组件中的CSS scoped vue组件中，style标签中属性scoped。该属性会让该组件下的css样式只适用于本组件，而不会影响全局组件。\nVue element ui 表格显示序号 1 2 3 4 5 \u0026lt;el-table-column fixed label=\u0026#34;序号\u0026#34; width=\u0026#34;50\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;template scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{scope.$index + 1}} \u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; 保存前端文件列表的问题 前端的上传的文件地址列表保存到数据库，后端报sql异常 Incorrect string value: '\\xAC\\xED\\x00\\x05sr...' for column 'appendix' at row 1\n原因竟是没有toString() :D 列表 -\u0026gt; varchar？\nVue动态加载组件问题 已知webpack支持动态加载，es6新增import()函数支持动态加载，import()返回一个 Promise 对象\nhttps://blog.csdn.net/qq_38211205/article/details/124348464\n动态加载组件可以写成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;component :is=\u0026#34;component\u0026#34; v-if=\u0026#34;component\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;test\u0026#39;, props: [\u0026#39;data\u0026#39;, \u0026#39;type\u0026#39;], data() { return { component: null } }, computed: { loader() { return () =\u0026gt; import(`@components/demo/demoTemplates/${type}`) } }, mounted() { this.loader().then(() =\u0026gt; { this.component = () =\u0026gt; this.loader() }).catch(() =\u0026gt; { this.component = () =\u0026gt; import(\u0026#39;@components/demo/demoTemplates/defaultDemo\u0026#39;) }) } } \u0026lt;/script\u0026gt; 但在实际使用中发现，import并不是完全动态的，或者说webpack并不能完全的动态加载，如：\n1 2 3 4 5 let path = `@/components/forms/${this.formType}`; this.formComponent = () =\u0026gt; import(path); // 或是 let path = \u0026#39;@/components/forms/\u0026#39; + this.formType; this.formComponent = () =\u0026gt; import(path); 这种情况并不能实现动态加载，”webpack 编译es6 动态引入 import() 时不能传入变量“，也就是webpack并不能实现完全动态。可以通过字符串模板来提供部分信息给webpack，例如import(`@/views/${path}`), 这样编译时会编译所有@/views下的模块，但运行时确定path的值才会加载，从而实现懒加载。\n个人猜想是webpack有一部分路径作为根据才能匹配模块进行编译，否则它并不知道要加载编译哪些模块。\n但在如此import之后在我的项目中依旧报错：\n1 2 3 4 5 6 vue.runtime.esm.js?2b0e:619 [Vue warn]: Failed to resolve async component: function () { return Promise.resolve(\u0026#34;@/\u0026#34;.concat(_this.curPath)).then(function (s) { return (0, _interopRequireWildcard2.default)(__webpack_require__(\u0026#34;./src/components/CommonForm sync recursive\u0026#34;)(s)); }); } Reason: Error: Cannot find module \u0026#39;@/components/forms/credit\u0026#39; sync recursive 递归？不太理解\n网上查到的类似的解决办法有（发现的顺序是3-1-2）：\n缺少webpack-cli，webpack4.x中部分功能交给webpack-cli了，\nnpm安装webpack-cli报错依旧，未解决。 import属于异步引用组件，需要babel-loader处理\n查看项目中有这个模块，且在babel配置文件中发现已配置该插件，还有注释内容\n1 2 // babel-plugin-dynamic-import-node plugin only does one thing by converting all import() to require(). // This plugin can significantly increase the speed of hot updates, when you have a large number of pages. 这和下一点使用的方式竟还有些交集。\n如何解决 Critical dependency: the request of a dependency is an expression ？ webpack4中动态import不支持变量方式。使用require加载，Promise.resolve(require(`@/views/${view}`).default)\n最终是使用require加载解决的。总结这些是觉得问题很奇怪在尝试解决import，因为感觉import和require二者并无太大区别。最终妥协并接纳了第三点中webpack4中动态import不支持变量方式的说法。\n使用require的方式：\n1 this.formComponent = () =\u0026gt; Promise.resolve(require(`@/views/${this.curPath}`).default) 使用require中也验证了不能完全动态加载说法，因此让路径中一部分作为模板@/views/来匹配。\n在解决问题的过程中好像看到import()和require()其中一个区别是前者是异步，后者是同步加载。\nXD 让我心痒痒的，在把require抽成方法后使用async await可以让他变成异步吗？\n捕获require MODULE_NOT_FOUND 异常 Handle errors thrown by require() module in node.js\n上节使用require加载模块，如果传入的路径错误require抛出异常(console中)，组件固然也无法正常加载，弹出的页面/对话框就是空白的，用户体验肯定是很不好的。 作为后端最先能想到的就是try-catch-finally，理想的逻辑是出错跳转/展示默认页面告知用户出错情况及可能原因。\n因此优雅的解决方法之一，将require抽成方法：\n1 2 3 4 5 6 7 8 9 10 11 12 requireMod(modulePath) { let module; try { module = require(\u0026#39;@/views/\u0026#39;+modulePath).default; } catch (e) { module = require(\u0026#39;@/components/CommonForm/default\u0026#39;).default; if (e.code !== \u0026#39;MODULE_NOT_FOUND\u0026#39;) { throw e; } } return module; } 如此，在模块加载不到的情况下返回默认组件，其他错误情况下，抛出异常。\n1 2 3 4 5 6 7 8 9 10 11 12 async requireMod(modulePath) { let module; try { module = await require(\u0026#39;@/views/\u0026#39;+modulePath).default; } catch (e) { module = require(\u0026#39;@/components/CommonForm/default\u0026#39;).default; if (e.code !== \u0026#39;MODULE_NOT_FOUND\u0026#39;) { throw e; } } return module; } 听说async await能让方法变异步？改造一下吧，这样方法会等待require('@/views/'+modulePath).default执行成功并Promise.resolve(）这样一下，返回promise。那我调用就可以这样：\n1 this.formComponent = () =\u0026gt; this.requireMod(this.curPath); 不用自己这样封装：\n1 this.formComponent = () =\u0026gt; Promise.resolve(require(`@/views/${this.curPath}`).default) 作为前端门外汉，目前还尚未有时间深入了解Promise。这个问题就到此吧。\nVue v-for循环中动态绑定失效 场景：使用v-for动态增加/删除展示的区块（el-container）\n1 \u0026lt;div v-for=\u0026#34;(item, index) in form.posts\u0026#34; :key=\u0026#34;index\u0026#34; \u0026gt; 同时需要根据变量的有无动态显示/隐藏和，通过@click.native=\u0026quot;postChange(item, index)\u0026quot;在选中选项后为item中增加一个name属性，用于在中展示。\n实际上，经此操作改变了item中的值，但在页面中没有及时刷新导致中不显示或显示为undefined\n最终通过Vue方法this.$forceUpdate() 来强制Vue实例重新渲染，解决问题。\nhttp://www.webzsky.com/?p=1415\n另外：\n「注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。」 update: this.$set()也是用于此类 数据已经添加/修改，但是页面没有响应式的渲染属性 的问题\nthis.$set(target, key, value) target：表示数据源，即是你要操作的数组或者对象 key：要操作的的字段 value：更改的数据\nJS中的值复制与引用复制 this.allUserList = this.selections； https://zhuanlan.zhihu.com/p/364336784\nJS正则表达式 i g m i 不区分大小写\ng 匹配多次，返回数组\nm 匹配多行\nVue监听的奇妙问题 监听某个值，但是另有一个操作将其置为null，此时能够监听到此值由初始变为null，但后续监听失效。解决：重置操作换成 xxx = \u0026lsquo;\u0026rsquo;;\nVue表单回显不可编辑的奇妙问题 问题场景：从列表展示页面点击编辑按钮，获取该项详细数据，跳转至编辑页面并将数据回显至表单\n问题描述：其中一项数据不能编辑\n不可编辑大概率和数据绑定有关系，所以第一步就检查了表单数据该项的定义，虽然该数据在不同情况下是不同的数据类型，但在data中定义了null/undefined应该没有问题。\n网上找到 https://blog.csdn.net/qq_57528681/article/details/125634981 中说到回显的表单数据不可编辑可能是因为回传的数据不可编辑，那就转一下吧： data -\u0026gt; string -\u0026gt; obj\n1 const data = JSON.parse(JSON.stringify(response.data)); 结果一样，不能编辑\n又找到 https://www.jb51.net/article/245758.htm\nVue的响应式属性是通过属性的getter/setter实现，而在Vue实例创建时，属性未声明则导致不能触发视图更新。\n其实在第一步检查中就已考虑的该问题，因此怀疑是否设置的初始类型也有影响，在不确定undefined会不会导致问题的情况下又将定义类型改为null，结果相同，因此问题不在此。\n最终破案：在获取数据后为了方便使用了如下的赋值方式\n1 2 3 4 this.form = { xxx: response.data.xxx, ... } 又因为其中一项需要根据类型动态赋不同值，没有在this.form = {}中赋值，因此此时form中是没有该项数据的，导致了不可编辑的问题，最后在其中加上yyy: null解决问题，如\n1 2 3 4 5 this.form = { xxx: response.data.xxx, ... yyy: null } PS. 这种赋值语句在需要改变对象的部分属性值时会导致其他属性丢失。如还是表单回显编辑场景下回传了数据项id至表单数据中，即form.id = 1; 而此时又有“在下拉框值变动时重置已填数据”的需求，如果在清空数据是采用此种方式赋值而没包含id会导致id数据丢失，继而导致更新数据失败。\nel-dialog destroy-on-close 子组件的生命周期问题 https://www.jianshu.com/p/2a11d95ffd2e\n“经过测试发现，把el-dialog标签写在父组件不写在子组件再使用destroy-on-close属性，实际它只能初始化dialog组件内部包裹的子组件data数据！！而且子组件的生命周期函数钩子会在关闭弹窗后还会执行一次！！，这样就感觉destroy-on-close很鸡肋”\n这种情况是el-dialog标签在父组件中，但其中包裹的内容封装在子组件中。那此时使用el-dialog的destroy-on-close虽然能够重置子组件中数据但子组件的生命周期会变的很奇怪。\n在此情况下，若在子组件的created钩子函数中进行数据请求和加载显然无法满足需求，如数据不能及时回显，因为子组件在dialog关闭后执行钩子函数。\n对此用法，可不使用destroy-on-close属性，而是通过v-if控制子组件和dialog同步加载：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;el-dialog :title=\u0026#34;title\u0026#34; :visible.sync=\u0026#34;openUserDialog\u0026#34; width=\u0026#34;1050px\u0026#34; append-to-body center\u0026gt; \u0026lt;user-dialog v-if=\u0026#34;openUserDialog\u0026#34; ref=\u0026#34;userDialog\u0026#34; @echo=\u0026#34;echoSelection\u0026#34; @selectAll=\u0026#34;selectAll\u0026#34; /\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34; class=\u0026#34;dialog-footer\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;handleUserSave\u0026#34;\u0026gt;保 存\u0026lt;/el-button\u0026gt; \u0026lt;el-button @click=\u0026#34;openUserDialog = false\u0026#34;\u0026gt;取 消\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-dialog\u0026gt; Vue父子组件动态传值及数据同步dialog为例 TODO.\n下次一定. 11-14\n下次一定. 11-23\n2023-02-02\n如在自定义对话框组件的使用中：\n父组件向子组件： 父组件向子组件传值：通过数据绑定将数据传递给子组件\n1 2 3 4 5 \u0026lt;user-single-dialog :title=\u0026#34;title\u0026#34; width=\u0026#34;1100px\u0026#34; :visible.sync=\u0026#34;userSglOpen\u0026#34; @handleSelect=\u0026#34;handleUserSelect\u0026#34;/\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import UserSingleDialog from \u0026#34;@/views/components/UserSingleDialog\u0026#34;; components: { UserSingleDialog } data() { return { title: \u0026#39;\u0026#39;, userSglOpen: false } } methods: { /** * 对话框子组件emit触发并传递数据 * @param selection 对话框选中的数据 */ handleUserSelect(selection) { // 数据操作 // ... } } 子组件中：通过props接收父组件的传值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script\u0026gt; export default { props: { title: { type: String, required: true, default: \u0026#39;用户选择\u0026#39; }, visible: { type: Boolean, required: true, default: false }, width: { type: String, required: true, default: \u0026#39;1100px\u0026#39; } }, } \u0026lt;/script\u0026gt; 子组件向父组件： 子组件通过使用$emit触发父组件的自定义事件\n如对话框子组件中，选中人员并点击保存按钮时使用$emit触发父组件中的handleSelect事件，并将选中的数据this.selection传递给父组件\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; export default { methods: { handleUserSave() { this.$emit(\u0026#39;handleSelect\u0026#39;, this.selection); this.open = false; }, } } \u0026lt;/script\u0026gt; 父组件中在自定义事件触发时调用相应方法获取并操作数据\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;user-single-dialog ref=\u0026#34;userSglDialog\u0026#34; :title=\u0026#34;title\u0026#34; width=\u0026#34;1100px\u0026#34; :visible.sync=\u0026#34;userSglOpen\u0026#34; @echo=\u0026#34;echoSelection\u0026#34; @handleSelect=\u0026#34;handleUserSelect\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script\u0026gt; import UserSingleDialog from \u0026#34;@/views/components/UserSingleDialog\u0026#34;; export default { name: \u0026#34;sample\u0026#34;, components: { UserSingleDialog }, methods: { /** * 对话框子组件emit触发并传递数据 * @param selection 对话框选中的数据 */ handleUserSelect(selection) { this.selection = selection; this.form.user_names = selection.user_name; this.echoId = selection.user_id; } } } \u0026lt;/script\u0026gt; 父子组件数据同步： .sync 修饰符\nhttps://v2.cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\n如Vue文档中所述：『在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题』 从2.3.0起Vue重新引入了.sync修饰符，但是只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on监听器。如：\n1 \u0026lt;comp :foo.sync=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/comp\u0026gt; 会被扩展为：\n1 \u0026lt;comp :foo=\u0026#34;bar\u0026#34; @update:foo=\u0026#34;val =\u0026gt; bar = val\u0026#34;\u0026gt;\u0026lt;/comp\u0026gt; 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n1 this.$emit(\u0026#39;update:foo\u0026#39;, newValue) 因此.sync 修饰符的作用是当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。\n说是v-model也能实现？\n如在自定义对话框组件的使用中：通过监听父组件传递的visible控制对话框子组件的open，同时子组件对话框关闭时同步更新父组件中的visible值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;script\u0026gt; export default { watch: { visible(val) { if (val != null) { this.open = val; } }, open: { handler(val) { this.$emit(\u0026#39;update:visible\u0026#39;, val) }, deep: true, immediate: true } }, } \u0026lt;/script\u0026gt; elementui el-form-item标签和输入控件在页面缩放时不在同一行 运用el-form自带属性 :inline\n“设置 inline 属性可以让表单域变为行内的表单域”\n1 \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;formInline\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; 但是如果设置了栅格布局 el-row + el-col 时，el-col的span属性会设定长度比例，此时缩放页面依旧会样式变化，因此需将表单中布局删除\nref 在 v-for undefined https://blog.csdn.net/weixin_34217773/article/details/91398408\n需求：在展示一张已填写过的试卷（问卷/投票）时，使用原控件，如radio（单选框）checkbox（多选框）将试卷实例数据回显，即展示回答情况。在此场景下，这些控件应为禁用状态，较为方便的操作是在el-form中使用disabled属性，可将form表单内的所有输入组件全部禁用。\n这样简单的回显+禁用已经实现，但disabled ≠ readonly，简单的将表单禁用导致所有组件都为灰色会让用户感觉“有问题”/“不和谐”。因此决定将控制组件disabled样式的类is-disabled在页面渲染完成之后删除，这样达到只读的效果。\nKao. 背景写这么长。\n在此过程发现一个问题，因为题目是使用v-for循环产生的，尝试在mounted钩子函数中使用window.document.getElementByClass或是使用更高级的ES6中的querySelector或是Vue的refs都是获取不到，如：\n1 2 3 4 5 6 7 8 9 \u0026lt;div v-for=\u0026#34;(question, index) in voteIns.questions\u0026#34; :key=\u0026#34;question.question_id\u0026#34;\u0026gt; \u0026lt;el-radio-group size=\u0026#34;small\u0026#34; v-if=\u0026#34;question.question_type == 0\u0026#34; v-model=\u0026#34;radioList[index]\u0026#34;\u0026gt; \u0026lt;el-radio v-for=\u0026#34;(option, idx) in question.options\u0026#34; :key=\u0026#34;idx\u0026#34; ref=\u0026#34;check\u0026#34; :label=\u0026#34;option.option_id\u0026#34; \u0026gt;{{option.option_content}}\u0026lt;/el-radio\u0026gt; \u0026lt;/div\u0026gt; 在mounted中打印refs的DOM元素，结果为undefined\n1 2 $refs {paperDetailForm: VueComponent} $refs.check undefined 原因是在mounted周期中，只是把组件模板的静态数据渲染了，动态绑定的Dom并没有初始化，所以在mounted周期里面获取不到DOM元素。 解决方法也如该博主所说：在数据加载并绑定之后操作DOM\n1 2 3 4 5 6 this.$nextTick(() =\u0026gt; { this.$refs.check.forEach(check =\u0026gt; { const className = check.$el.firstChild.className; check.$el.firstChild.className = className.replace(/is-disabled/, \u0026#39;\u0026#39;); }); }) ElementUI @keyup.enter.native 输入框回车事件导致页面刷新 如表单为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;el-form :model=\u0026#34;groupQueryParams\u0026#34; ref=\u0026#34;groupQueryForm\u0026#34; size=\u0026#34;small\u0026#34; :inline=\u0026#34;true\u0026#34; label-width=\u0026#34;68px\u0026#34; @submit.native.prevent\u0026gt; \u0026lt;el-form-item prop=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;groupQueryParams.name\u0026#34; placeholder=\u0026#34;请输入分组名称\u0026#34; clearable @keyup.enter.native=\u0026#34;handleQuery(1)\u0026#34; /\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; plain size=\u0026#34;mini\u0026#34; @click=\u0026#34;handleQuery(1)\u0026#34;\u0026gt;搜索\u0026lt;/el-button\u0026gt; \u0026lt;el-button plain size=\u0026#34;mini\u0026#34; @click=\u0026#34;resetQuery(1)\u0026#34;\u0026gt;重置\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; 表单groupQueryForm中只有一个输入框，回车事件时并没有触发事件而是刷新了页面。\nhttps://blog.csdn.net/daipianpian/article/details/127105154\n『W3C标准的说法是：当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。如果希望阻止这一默认行为，可以在标签上添加@submit.native.prevent。』\n","date":"2022-11-14T00:00:00Z","permalink":"https://h-wanng.github.io/p/vue-js-issues/","title":"Vue \u0026 JS Issues"},{"content":"Long值的比较判断相等问题 业务场景为数据库中主键id字段类型为bigint（因为雪花算法自增），后端代码使用对应的数据类型是Long。\n1 2 3 4 5 6 public DTree(Map\u0026lt;String, Object\u0026gt; node) { this.id = (Long) node.get(\u0026#34;id\u0026#34;); this.label = (String) node.get(\u0026#34;label\u0026#34;); this.parentId = (Long) node.get(\u0026#34;parent_id\u0026#34;); this.children = null; } 实际上，MySQL中有符号类型 Bigint(20)的取值范围为-9223372036854775808~9223372036854775807，与Java.lang.Long的取值范围完全一致，mybatis/mybatis-plus会将 Bigint(20)映射为Long类型。 ——CSDN 梦 * 蝶\n出现问题的情况为：\n当主键id位数大于3时，后端组树的业务代码将所有数据都作为根节点，前端显示为非“树”状列表，即全为父节点。\n排错后总结问题为id的判断出错，即==未能判断出两个id相等。类似的问题有 CSDN 火火火FF 和我的这个问题非常相似。\n其实排错过程中遇到超三位数就不能判断出结果就比较容易猜到Long型判断问题。\n问题比较有趣、典型，有必要记录一下。如 https://blog.csdn.net/cherry7005/article/details/112392459 中说明。\nlong是基本数据类型，判断是否相等时使用==，即可判断值是否相等。（基本数据类型没有equals()方法） Long是引用数据类型，当其数值在[-128,127]之间时，能用==判断是否相等，亦可用 \u0026gt;、\u0026lt; 比较大小。 java.lang.Long.java中：\n1 2 3 4 5 6 7 8 9 10 private static class LongCache { private LongCache(){} static final Long cache[] = new Long[-(-128) + 127 + 1]; static { for(int i = 0; i \u0026lt; cache.length; i++) cache[i] = new Long(i - 128); } } LongCache会预先缓存 [-128,127] 范围内的数，通过缓存频繁请求的值代来更好的空间和时间性能，当数据超出此范围，则new一个Long对象；\n“==”是比较的地址，超出此范围的数据地址不一致，所以范围内的比较是true，范围外的数据是false。\n另外，Java对于每一种基本数据类型都会创建一个缓存池。基本数据类型对应的缓存池如下：\nboolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 使用对应的包装类型时，如果值范围在缓存池范围内，会直接引用缓存池中的对象，否则会创建新的对象。\n==判断的是地址，故在缓存池范围内的判断为true，而超出范围为false。\n所以对于包装类型的数值判断可以拆箱之后进行判断或使用equals().\n","date":"2022-09-13T00:00:00Z","permalink":"https://h-wanng.github.io/p/long-equals/","title":"Long '==' \u0026 'equals()'"},{"content":"错误介绍 在Python3中使用ROS会出现cv_bridge和tf报错问题 python 3.x - Unable to use cv_bridge with ROS Kinetic and Python3 - Stack Overflow\npython3 cv bridge报错\n1 ImportError: dynamic module does not define module export function (PyInit_cv_bridge_boost) tf tf2报错\n1 ImportError: dynamic module does not define module export function (PyInit__tf2) 解决的关键在于使用python3编译，可以通过下面参数进行cmake\n1 -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so 这里介绍常用的catkin工具进行编译\nROS Wiki中对于软件包的介绍 ROS tf Package ROS cv_bridge Package CV Bridge 依赖 python-catkin-tools catkin工具 python3-dev 和 python3-catkin-pkg-modules 用于编译 python3-numpy 和 python3-yaml cv_bridge依赖 ros-melodic-cv-bridge 通过 cv_bridge ros 包来安装和cv_bridge相关的依赖，在安装ROS过程中可能已经安装 1 sudo apt-get install python-catkin-tools python3-dev python3-catkin-pkg-modules python3-numpy python3-yaml ros-melodic-cv-bridge 创建catkin工作空间 1 mkdir -p cvbdg_ws/src 1 2 cd cvbdg_ws catkin init 配置catkin编译参数 设置使用python3编译\n1 catkin config -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so 其中/usr/include/python3.6m /usr/lib/x86_64-linux-gnu/libpython3.6m.so 是系统中python3解释器及相关库文件位置，根据具体情况替换\n设置编译安装位置 位于$CATKIN_WORKSPACE/install 目录下\n1 catkin config --install clone cv_bridge 源码 1 git clone https://github.com/ros-perception/vision_opencv.git src/vision_opencv 检查版本 1 2 3 apt-cache show ros-kinetic-cv-bridge | grep Version # 结果 Version: 1.13.0-0bionic.20210505.0322380 检查git仓库中是否有对应版本并检出 1 2 3 4 cd src/vision_opencv/ git checkout 1.13.0 #返回工作空间主目录 cd ../../ 编译cv bridge 1 catkin build cv_bridge 设置环境变量 使用 --extend 命令source附加环境变量\n1 source install/setup.bash --extend 因为每次使用都需要这样的source操作，可以将其加入 .bashrc 中打开终端自动执行\n1 echo \u0026#34;source $HOME/cvbdg_ws/install/setup.bash --extend\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 测试 1 2 3 4 5 6 7 $ python3 Python 3.5.2 (default, Nov 23 2017, 16:37:01) [GCC 5.4.0 20160609] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; from cv_bridge.boost.cv_bridge_boost import getCvType \u0026gt;\u0026gt;\u0026gt; 如果没有再出现错误即编译安装成功\nTF TF2 依赖 和安装编译cv bridge相同，安装部分依赖\n1 sudo apt-get install python-catkin-tools python3-dev python3-catkin-pkg-modules python3-numpy python3-yaml ros-melodic-geometry ros-melodic-geometry2 创建catkin工作空间\n1 mkdir -p tf_ws/src 1 2 cd tf_ws catkin init 配置catkin编译参数 设置使用python3编译\n1 catkin config -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so 设置编译安装位置 位于$CATKIN_WORKSPACE/install 目录下\n1 catkin config --install clone 源码 1 2 git clone -b melodic-devel https://github.com/ros/geometry git clone -b melodic-devel https://github.com/ros/geometry2 检查版本 检查系统中安装的软件包版本\n1 2 3 apt-cache show ros-melodic-geometry | grep Version # 结果 Version: 1.12.1-1bionic.20210505.035349 编译tf tf2 1 catkin build 环境变量 使用 --extend 命令source附加环境变量\n1 source install/setup.bash --extend 加入 .bashrc 中打开终端自动执行\n1 echo \u0026#34;source $HOME/tf_ws/install/setup.bash --extend\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 测试 1 2 3 4 5 6 7 $ python3 Python 3.5.2 (default, Nov 23 2017, 16:37:01) [GCC 5.4.0 20160609] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import tf \u0026gt;\u0026gt;\u0026gt; 如果没有再出现错误即编译安装成功\n另外，可以通过源码编译的方式安装ROS，使ROS支持Python3 如：Building ROS Melodic with Python3 support\n","date":"2021-09-20T00:00:00Z","image":"https://h-wanng.github.io/p/ros-python3/python3-ros_hu6483746117518016101.png","permalink":"https://h-wanng.github.io/p/ros-python3/","title":"ROS Python3"},{"content":"0 依赖 UUV Simulator是基于ROS与Gazebo开发实现的，其安装依赖ROS和catkin工具\n0.1 ROS Ubuntu18.04 对应 ROS Melodic\nROS的安装请参考 Docs中简单的安装介绍 或 melodic/Installation/Ubuntu - ROS Wiki\n0.2 catkin_tools 1 sudo apt-get install python3-catkin-tools 1 安装 源码安装基于 ROS Melodic 和 Gazebo9 的 uuv-simulator.\n1.1 创建ROS工作空间 1 2 mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src 1.2 初始化catkin工作空间 1 2 cd ~/catkin_ws catkin init 1.3 clone源码 1 2 3 4 cd ~/catkin_ws/src git clone https://github.com/uuvsimulator/uuv_simulator.git # 若从git clone 失败，使用国内 gitee 地址 # git clone https://gitee.com/h_wanng/uuv_simulator.git 1.4 软件包依赖安装 Note: 如果安装ROS过程中最后一步依赖更新 rosdep update 失败，那么将会很大概率会影响本步操作。\n1 2 cd ~/catkin_ws rosdep install --from-paths src --ignore-src --rosdistro=melodic -y --skip-keys \u0026#34;gazebo gazebo_msgs gazebo_plugins gazebo_ros gazebo_ros_control gazebo_ros_pkgs\u0026#34; 1.5 编译 1 2 cd ~/catkin_ws catkin_make install Note: 编译过程比较耗费内存，如果报错大多和内存相关。可以尝试：\n重复编译操作； 增加虚拟内存(Swap) 1.6 配置环境变量 1 2 echo \u0026#34;source $HOME/catkin_ws/devel/setup.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 1.7 测试 1 roslaunch uuv_gazebo_worlds ocean_waves.launch launch文件启动Gazebo后显示如下场景即安装成功\n","date":"2021-09-20T00:00:00Z","image":"https://h-wanng.github.io/p/uuv-simulator-installation/ocean_waves_hu3476100586691704369.png","permalink":"https://h-wanng.github.io/p/uuv-simulator-installation/","title":"UUV Simulator Installation"},{"content":"ROS Wiki Ubuntu install of ROS Melodic\n较简单，按官方文档进行安装即可。\nNote\n选择国内镜像源进行配置安装, 如下图1中Mirrors 安装完成在终端执行roscore测试安装情况，如下图2中执行结果所示 ","date":"2021-09-17T00:00:00Z","image":"https://h-wanng.github.io/p/ros-melodic-installation/ros-melodic_hu15979678700514432480.png","permalink":"https://h-wanng.github.io/p/ros-melodic-installation/","title":"ROS Melodic Installation"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-09-16T00:00:00Z","image":"https://h-wanng.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://h-wanng.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]